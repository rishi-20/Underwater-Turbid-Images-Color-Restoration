{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7d19edff",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import datetime\n",
    "import numpy as np\n",
    "import cv2\n",
    "import natsort\n",
    "import math"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "13ca6d7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Determine depth\n",
    "\n",
    "def getMAxChannel(img):\n",
    "    imgGray = np.zeros((img.shape[0], img.shape[1]), 'float32')\n",
    "    for i in range(0, img.shape[0]):\n",
    "        for j in range(0, img.shape[1]):\n",
    "            localMax = 0\n",
    "            for k in range(0, 2):\n",
    "                if img.item((i, j, k)) > localMax:\n",
    "                    localMax = img.item((i, j, k))\n",
    "            imgGray[i, j] = localMax\n",
    "    return imgGray\n",
    "\n",
    "\n",
    "def getDarkChannel(img, blockSize):\n",
    "    addSize = int((blockSize - 1) / 2)\n",
    "    newHeight = img.shape[0] + blockSize - 1\n",
    "    newWidth = img.shape[1] + blockSize - 1\n",
    "\n",
    "    imgMiddle = np.zeros((newHeight, newWidth))\n",
    "    imgMiddle[:, :] = 0\n",
    "    imgMiddle[addSize:newHeight - addSize, addSize:newWidth - addSize] = img\n",
    "    # print('imgMiddle',imgMiddle)\n",
    "    imgDark = np.zeros((img.shape[0], img.shape[1]), dtype=np.float16)\n",
    "    localMax = 0\n",
    "    for i in range(addSize, newHeight - addSize):\n",
    "        for j in range(addSize, newWidth - addSize):\n",
    "            localMax = 0\n",
    "            for k in range(i - addSize, i + addSize + 1):\n",
    "                for l in range(j - addSize, j + addSize + 1):\n",
    "                    if imgMiddle.item((k, l)) > localMax:\n",
    "                        localMax = imgMiddle.item((k, l))\n",
    "            imgDark[i - addSize, j - addSize] = localMax\n",
    "    return imgDark\n",
    "\n",
    "\n",
    "def determineDepth(img, blockSize):\n",
    "    img2 = img/255\n",
    "    img_GB = getMAxChannel(img2)\n",
    "    Max_GB = getDarkChannel(img_GB, blockSize)\n",
    "    Max_R  = getDarkChannel(img2[:,:,2], blockSize)\n",
    "    largestDiff = Max_R  - Max_GB\n",
    "\n",
    "    return largestDiff"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "d1cd74a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Transmission Estimation\n",
    "\n",
    "def getTransmission(normI,AtomsphericLight ,w):\n",
    "    M, N, C = normI.shape #M are the rows, N are the columns, C is the bgr channel\n",
    "    B = AtomsphericLight\n",
    "    padwidth = math.floor(w/2)\n",
    "    padded = np.pad(normI/B, ((padwidth, padwidth), (padwidth, padwidth),(0,0)), 'constant')\n",
    "    transmission = np.zeros((M,N,2))\n",
    "    for y, x in np.ndindex(M, N):\n",
    "        transmission[y,x,0] = 1 - np.min(padded[y : y+w , x : x+w , 0])\n",
    "        transmission[y,x,1] = 1 - np.min(padded[y : y+w , x : x+w , 1])\n",
    "    return transmission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "c1da3190",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Guided Filter\n",
    "\n",
    "class GuidedFilter:\n",
    "    \n",
    "    # def __init__(self, I, radius=5, epsilon=0.4):\n",
    "    def __init__(self, I, radius, epsilon):\n",
    "\n",
    "        self._radius = 2 * radius + 1\n",
    "        self._epsilon = epsilon\n",
    "        self._I = self._toFloatImg(I)\n",
    "        self._initFilter()\n",
    "\n",
    "        # print('radius',self._radius)\n",
    "        # print('epsilon',self._epsilon)\n",
    "\n",
    "    def _toFloatImg(self, img):\n",
    "        if img.dtype == np.float32:\n",
    "            return img\n",
    "        return ( 1.0 / 255.0 ) * np.float32(img)\n",
    "\n",
    "    def _initFilter(self):\n",
    "        I = self._I\n",
    "        r = self._radius\n",
    "        eps = self._epsilon\n",
    "\n",
    "        Ir, Ig, Ib = I[:, :, 0], I[:, :, 1], I[:, :, 2]\n",
    "\n",
    "        # self._Ir_mean = cv2.blur(Ir, (r, r))\n",
    "        # self._Ig_mean = cv2.blur(Ig, (r, r))\n",
    "        # self._Ib_mean = cv2.blur(Ib, (r, r))\n",
    "        #\n",
    "        # Irr_var = cv2.blur(Ir ** 2, (r, r)) - self._Ir_mean ** 2 + eps\n",
    "        # Irg_var = cv2.blur(Ir * Ig, (r, r)) - self._Ir_mean * self._Ig_mean\n",
    "        # Irb_var = cv2.blur(Ir * Ib, (r, r)) - self._Ir_mean * self._Ib_mean\n",
    "        # Igg_var = cv2.blur(Ig * Ig, (r, r)) - self._Ig_mean * self._Ig_mean + eps\n",
    "        # Igb_var = cv2.blur(Ig * Ib, (r, r)) - self._Ig_mean * self._Ib_mean\n",
    "        # Ibb_var = cv2.blur(Ib * Ib, (r, r)) - self._Ib_mean * self._Ib_mean + eps\n",
    "\n",
    "\n",
    "        self._Ir_mean = cv2.blur(Ir, (r, r))\n",
    "        self._Ig_mean = cv2.blur(Ig, (r, r))\n",
    "        self._Ib_mean = cv2.blur(Ib, (r, r))\n",
    "\n",
    "        Irr_var = cv2.blur(Ir ** 2, (r, r)) - self._Ir_mean ** 2 + eps                                       \n",
    "        Irg_var = cv2.blur(Ir * Ig, (r, r)) - self._Ir_mean * self._Ig_mean                                  \n",
    "        Irb_var = cv2.blur(Ir * Ib, (r, r)) - self._Ir_mean * self._Ib_mean                                  \n",
    "        Igg_var = cv2.blur(Ig * Ig, (r, r)) - self._Ig_mean * self._Ig_mean + eps                            \n",
    "        Igb_var = cv2.blur(Ig * Ib, (r, r)) - self._Ig_mean * self._Ib_mean                                  \n",
    "        Ibb_var = cv2.blur(Ib * Ib, (r, r)) - self._Ib_mean * self._Ib_mean + eps                                                       \n",
    "\n",
    "\n",
    "        Irr_inv = Igg_var * Ibb_var - Igb_var * Igb_var                                                      \n",
    "        Irg_inv = Igb_var * Irb_var - Irg_var * Ibb_var                                                      \n",
    "        Irb_inv = Irg_var * Igb_var - Igg_var * Irb_var                                                      \n",
    "        Igg_inv = Irr_var * Ibb_var - Irb_var * Irb_var                                                      \n",
    "        Igb_inv = Irb_var * Irg_var - Irr_var * Igb_var                                                      \n",
    "        Ibb_inv = Irr_var * Igg_var - Irg_var * Irg_var                                                      \n",
    "        \n",
    "        I_cov = Irr_inv * Irr_var + Irg_inv * Irg_var + Irb_inv * Irb_var                                    \n",
    "        Irr_inv /= I_cov                                                                                     \n",
    "        Irg_inv /= I_cov                                                                                     \n",
    "        Irb_inv /= I_cov                                                                                     \n",
    "        Igg_inv /= I_cov                                                                                     \n",
    "        Igb_inv /= I_cov                                                                                     \n",
    "        Ibb_inv /= I_cov                                                                                     \n",
    "        \n",
    "        self._Irr_inv = Irr_inv                                                                              \n",
    "        self._Irg_inv = Irg_inv                                                                              \n",
    "        self._Irb_inv = Irb_inv                                                                              \n",
    "        self._Igg_inv = Igg_inv                                                                              \n",
    "        self._Igb_inv = Igb_inv                                                                              \n",
    "        self._Ibb_inv = Ibb_inv                  \n",
    "\n",
    "    def _computeCoefficients(self, p):\n",
    "        r = self._radius                                                             \n",
    "        I = self._I                                                                 \n",
    "        Ir, Ig, Ib = I[:, :, 0], I[:, :, 1], I[:, :, 2]                                                          \n",
    "        \n",
    "\n",
    "        p_mean = cv2.blur(p, (r, r))                             \n",
    "        Ipr_mean = cv2.blur(Ir * p, (r, r))                                                         \n",
    "        Ipg_mean = cv2.blur(Ig * p, (r, r))                                                    \n",
    "        Ipb_mean = cv2.blur(Ib * p, (r, r))             \n",
    "\n",
    "\n",
    "\n",
    "        Ipr_cov = Ipr_mean - self._Ir_mean * p_mean                                                 \n",
    "        Ipg_cov = Ipg_mean - self._Ig_mean * p_mean                                                     \n",
    "        Ipb_cov = Ipb_mean - self._Ib_mean * p_mean                                                       \n",
    "                                                                                                                 \n",
    "        ar = self._Irr_inv * Ipr_cov + self._Irg_inv * Ipg_cov + self._Irb_inv * Ipb_cov                 \n",
    "        ag = self._Irg_inv * Ipr_cov + self._Igg_inv * Ipg_cov + self._Igb_inv * Ipb_cov                \n",
    "        ab = self._Irb_inv * Ipr_cov + self._Igb_inv * Ipg_cov + self._Ibb_inv * Ipb_cov    \n",
    "\n",
    "        b = p_mean - ar * self._Ir_mean - ag * self._Ig_mean - ab * self._Ib_mean                                                                                                                                         \n",
    "\n",
    "        ar_mean = cv2.blur(ar, (r, r))          \n",
    "        ag_mean = cv2.blur(ag, (r, r))                                                                   \n",
    "        ab_mean = cv2.blur(ab, (r, r))                                                                      \n",
    "        b_mean = cv2.blur(b, (r, r))                                                                                                                                              \n",
    "\n",
    "        return ar_mean, ag_mean, ab_mean, b_mean            \n",
    "\n",
    "    def _computeOutput(self, ab, I):\n",
    "    \n",
    "        ar_mean, ag_mean, ab_mean, b_mean = ab\n",
    "        Ir, Ig, Ib = I[:, :, 0], I[:, :, 1], I[:, :, 2]\n",
    "        q = ar_mean * Ir + ag_mean * Ig + ab_mean * Ib + b_mean\n",
    "        return q\n",
    "\n",
    "    def filter(self, p):\n",
    "\n",
    "        p_32F = self._toFloatImg(p)\n",
    "\n",
    "        ab = self._computeCoefficients(p)\n",
    "        return self._computeOutput(ab, self._I)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "89361a84",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Guided Filter_He\n",
    "\n",
    "from itertools import combinations_with_replacement\n",
    "from collections import defaultdict\n",
    "\n",
    "import numpy as np\n",
    "from numpy.linalg import inv\n",
    "\n",
    "R, G, B = 0, 1, 2  # index for convenience\n",
    "\n",
    "\n",
    "def boxfilter(I, r):\n",
    "    \"\"\"Fast box filter implementation.\n",
    "    Parameters\n",
    "    ----------\n",
    "    I:  a single channel/gray image data normalized to [0.0, 1.0]\n",
    "    r:  window radius\n",
    "    Return\n",
    "    -----------\n",
    "    The filtered image data.\n",
    "    \"\"\"\n",
    "    M, N = I.shape\n",
    "    dest = np.zeros((M, N))\n",
    "\n",
    "    # cumulative sum over Y axis\n",
    "    sumY = np.cumsum(I, axis=0)\n",
    "    # difference over Y axis\n",
    "    dest[:r + 1] = sumY[r: 2 * r + 1]\n",
    "    dest[r + 1:M - r] = sumY[2 * r + 1:] - sumY[:M - 2 * r - 1]\n",
    "    dest[-r:] = np.tile(sumY[-1], (r, 1)) - sumY[M - 2 * r - 1:M - r - 1]\n",
    "\n",
    "    # cumulative sum over X axis\n",
    "    sumX = np.cumsum(dest, axis=1)\n",
    "    # difference over Y axis\n",
    "    dest[:, :r + 1] = sumX[:, r:2 * r + 1]\n",
    "    dest[:, r + 1:N - r] = sumX[:, 2 * r + 1:] - sumX[:, :N - 2 * r - 1]\n",
    "    dest[:, -r:] = np.tile(sumX[:, -1][:, None], (1, r)) - \\\n",
    "        sumX[:, N - 2 * r - 1:N - r - 1]\n",
    "\n",
    "    return dest\n",
    "\n",
    "\n",
    "def guided_filter_he(I, p, r=40, eps=1e-3):\n",
    "    \"\"\"Refine a filter under the guidance of another (RGB) image.\n",
    "    Parameters\n",
    "    -----------\n",
    "    I:   an M * N * 3 RGB image for guidance.\n",
    "    p:   the M * N filter to be guided\n",
    "    r:   the radius of the guidance\n",
    "    eps: epsilon for the guided filter\n",
    "    Return\n",
    "    -----------\n",
    "    The guided filter.\n",
    "    \"\"\"\n",
    "    M, N = p.shape\n",
    "    base = boxfilter(np.ones((M, N)), r)\n",
    "\n",
    "    # each channel of I filtered with the mean filter\n",
    "    means = [boxfilter(I[:, :, i], r) / base for i in range(3)]\n",
    "    # p filtered with the mean filter\n",
    "    mean_p = boxfilter(p, r) / base\n",
    "    # filter I with p then filter it with the mean filter\n",
    "    means_IP = [boxfilter(I[:, :, i] * p, r) / base for i in range(3)]\n",
    "    # covariance of (I, p) in each local patch\n",
    "    covIP = [means_IP[i] - means[i] * mean_p for i in range(3)]\n",
    "\n",
    "    # variance of I in each local patch: the matrix Sigma in ECCV10 eq.14\n",
    "    var = defaultdict(dict)\n",
    "    for i, j in combinations_with_replacement(range(3), 2):\n",
    "        var[i][j] = boxfilter(\n",
    "            I[:, :, i] * I[:, :, j], r) / base - means[i] * means[j]\n",
    "\n",
    "    a = np.zeros((M, N, 3))\n",
    "    for y, x in np.ndindex(M, N):\n",
    "        #         rr, rg, rb\n",
    "        # Sigma = rg, gg, gb\n",
    "        #         rb, gb, bb\n",
    "        Sigma = np.array([[var[R][R][y, x], var[R][G][y, x], var[R][B][y, x]],\n",
    "                          [var[R][G][y, x], var[G][G][y, x], var[G][B][y, x]],\n",
    "                          [var[R][B][y, x], var[G][B][y, x], var[B][B][y, x]]])\n",
    "        cov = np.array([c[y, x] for c in covIP])\n",
    "        a[y, x] = np.dot(cov, inv(Sigma + eps * np.eye(3)))  # eq 14\n",
    "\n",
    "    # ECCV10 eq.15\n",
    "    b = mean_p - a[:, :, R] * means[R] - \\\n",
    "        a[:, :, G] * means[G] - a[:, :, B] * means[B]\n",
    "\n",
    "    # ECCV10 eq.16\n",
    "    q = (boxfilter(a[:, :, R], r) * I[:, :, R] + boxfilter(a[:, :, G], r) *\n",
    "         I[:, :, G] + boxfilter(a[:, :, B], r) * I[:, :, B] + boxfilter(b, r)) / base\n",
    "\n",
    "    return q\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "2cd8f579",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Get Adaptive Exposure Map\n",
    "\n",
    "np.seterr(over='ignore')\n",
    "np.seterr(invalid ='ignore')\n",
    "np.seterr(all ='ignore')\n",
    "\n",
    "\n",
    "#\n",
    "#  def AdaptiveExposureMap(img,sceneRadiance,Lambda,blockSize):\n",
    "#     img = np.float32(img)\n",
    "#     sceneRadiance = np.float32(sceneRadiance)\n",
    "#\n",
    "#     x = sceneRadiance * img + Lambda * (img **2 )\n",
    "#     y = sceneRadiance ** 2 + Lambda *  (img ** 2)\n",
    "#     S_x  = x / y\n",
    "#\n",
    "#     return S_x\n",
    "\n",
    "\n",
    "\n",
    "def AdaptiveExposureMap(img, sceneRadiance, Lambda, blockSize):\n",
    "\n",
    "    minValue = 10 ** -2\n",
    "    img = np.uint8(img)\n",
    "    sceneRadiance = np.uint8(sceneRadiance)\n",
    "\n",
    "    YjCrCb = cv2.cvtColor(sceneRadiance, cv2.COLOR_BGR2YCrCb)\n",
    "    YiCrCb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)\n",
    "    normYjCrCb = (YjCrCb - YjCrCb.min()) / (YjCrCb.max() - YjCrCb.min())\n",
    "    normYiCrCb = (YiCrCb - YiCrCb.min()) / (YiCrCb.max() - YiCrCb.min())\n",
    "    Yi = normYiCrCb[:, :, 0]\n",
    "    Yj = normYjCrCb[:, :, 0]\n",
    "    Yi = np.clip(Yi, minValue,1)\n",
    "    Yj = np.clip(Yj, minValue,1)\n",
    "\n",
    "    # print('np.min(Yi)',np.min(Yi))\n",
    "    # print('np.max(Yi)',np.max(Yi))\n",
    "    # print('np.min(Yj)',np.min(Yj))\n",
    "    # print('np.max(Yj)',np.max(Yj))\n",
    "    # Yi = YiCrCb[:, :, 0]\n",
    "    # Yj = YjCrCb[:, :, 0]\n",
    "    S = (Yj * Yi + 0.3 * Yi ** 2) / (Yj ** 2 + 0.3 * Yi ** 2)\n",
    "\n",
    "    # print('S',S)\n",
    "\n",
    "    gimfiltR = 50  \n",
    "    eps = 10 ** -3  \n",
    "\n",
    "    # refinedS = guided_filter_he(YiCrCb, S, gimfiltR, eps)\n",
    "\n",
    "    guided_filter = GuidedFilter(YiCrCb, gimfiltR, eps)\n",
    "    # guided_filter = GuidedFilter(normYiCrCb, gimfiltR, eps)\n",
    "\n",
    "    refinedS = guided_filter.filter(S)\n",
    "\n",
    "    # print('guided_filter_he(YiCrCb, S, gimfiltR, eps)', refinedS)\n",
    "    # S = np.clip(S, 0, 1)\n",
    "\n",
    "    # cv2.imwrite('OutputImages_D/' + 'SSSSS' + '_GBdehazingRCorrectionStretching.jpg', np.uint8(S * 255))\n",
    "\n",
    "    S_three = np.zeros(img.shape)\n",
    "    S_three[:, :, 0] = S_three[:, :, 1] = S_three[:, :, 2] = refinedS\n",
    "\n",
    "    return S_three"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "fc600610",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Get Adaptive Scene Radiance\n",
    "\n",
    "def AdaptiveSceneRadiance(sceneRadiance,S_x):\n",
    "    sceneRadiance = np.float64(sceneRadiance)\n",
    "    sceneRadiance  = sceneRadiance * S_x\n",
    "\n",
    "    sceneRadiance = np.clip(sceneRadiance, 0, 255)\n",
    "    sceneRadiance = np.uint8(sceneRadiance)\n",
    "    return sceneRadiance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "a8731f3b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Adaptive Atmospheric Light\n",
    "\n",
    "class Node(object):\n",
    "    def __init__(self,x,y,value):\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "        self.value = value\n",
    "    def printInfo(self):\n",
    "        print(self.x,self.y,self.value)\n",
    "\n",
    "\n",
    "def getAtomsphericLight(darkChannel, img):\n",
    "    img = np.float32(img)\n",
    "    height = darkChannel.shape[0]\n",
    "    width = darkChannel.shape[1]\n",
    "    nodes = []\n",
    "    \n",
    "    for i in range(0, height):\n",
    "        for j in range(0, width):\n",
    "            oneNode = Node(i, j, darkChannel[i, j])\n",
    "            nodes.append(oneNode)\n",
    "    \n",
    "    nodes = sorted(nodes, key=lambda node: node.value, reverse=False)\n",
    "    # print('nodes[0]',nodes[0].value)\n",
    "    # print('img[nodes[0].x, nodes[0].y, 0]+img[nodes[0].x, nodes[0].y, 1])',img[nodes[0].x, nodes[0].y, 0],img[nodes[0].x, nodes[0].y, 1])\n",
    "    atomsphericLight  = np.mean([img[nodes[0].x, nodes[0].y, 0],img[nodes[0].x, nodes[0].y, 1]])\n",
    "    atomsphericLightGB = img[nodes[0].x, nodes[0].y, 0:2]\n",
    "    atomsphericLightRGB = img[nodes[0].x, nodes[0].y, :]\n",
    "    # atomsphericLight  =  [img[nodes[0].x, nodes[0].y, 0],img[nodes[0].x, nodes[0].y, 1]]\n",
    "    return atomsphericLight,atomsphericLightGB,atomsphericLightRGB"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "c09ec77e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Refined Transmission\n",
    "\n",
    "def  refinedtransmission(transmission, img):\n",
    "    gimfiltR = 50  \n",
    "    eps = 10 ** -3  \n",
    "\n",
    "    guided_filter = GuidedFilter(img, gimfiltR, eps)\n",
    "    transmission[:,:,0] = guided_filter.filter(transmission[:,:,0])\n",
    "    transmission[:,:,1] = guided_filter.filter(transmission[:,:,1])\n",
    "    transmission = np.clip(transmission, 0.1, 0.9)\n",
    "\n",
    "\n",
    "    return transmission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "8438f939",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Scene RadianceGb\n",
    "\n",
    "def sceneRadianceGB(img,transmission,AtomsphericLight):\n",
    "    sceneRadiance = img.copy()\n",
    "    img = np.float32(img)\n",
    "    for i in range(0, 2):\n",
    "        sceneRadiance[:, :, i] = (img[:, :, i] - AtomsphericLight[i]) / transmission[:, :, i] + AtomsphericLight[i]\n",
    "        \n",
    "    sceneRadiance = (sceneRadiance - sceneRadiance.min()) / (sceneRadiance.max() - sceneRadiance.min()) * 255\n",
    "    sceneRadiance = np.clip(sceneRadiance, 0, 255)\n",
    "    sceneRadiance = np.uint8(sceneRadiance)\n",
    "\n",
    "    return sceneRadiance\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "a74b9b48",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Scene RadianceR\n",
    "\n",
    "def  sceneradiance(img, sceneRadiance_GB):\n",
    "    img = np.float32(img)\n",
    "    R_original = img[:, :, 2]\n",
    "    sceneRadiance_GB = np.float32(sceneRadiance_GB)\n",
    "\n",
    "    print('***********************************************************')\n",
    "    avgRr = 1.5 - (np.mean(sceneRadiance_GB[:,:,0])/255 +np.mean(sceneRadiance_GB[:,:,1])/255)\n",
    "    parameterR  =   avgRr  / ((np.mean(R_original))/255)\n",
    "\n",
    "    print('parameterR',parameterR)\n",
    "    sceneRadianceR = R_original * parameterR\n",
    "    sceneRadianceR = (sceneRadianceR - sceneRadianceR.min()) / (sceneRadianceR.max() - sceneRadianceR.min())\n",
    "    sceneRadianceR = sceneRadianceR * 255\n",
    "\n",
    "    sceneRadianceR = np.clip(sceneRadianceR, 0, 255)\n",
    "    sceneRadiance_GB[:, :, 2] = sceneRadianceR\n",
    "    sceneRadiance_GB = np.uint8(sceneRadiance_GB)\n",
    "    return  sceneRadiance_GB"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "7962ac34",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "********    file   ******** 2.png\n",
      "AtomsphericLightRGB [162.40224 131.06145  91.17319]\n",
      "***********************************************************\n",
      "parameterR 2.213047216117398\n",
      "********    file   ******** 5.png\n",
      "AtomsphericLightRGB [183.88446  241.79283    9.143426]\n",
      "***********************************************************\n",
      "parameterR 9.570121974010885\n",
      "********    file   ******** 34.png\n",
      "AtomsphericLightRGB [255. 161.  40.]\n",
      "***********************************************************\n",
      "parameterR 8.161306321288125\n",
      "********    file   ******** 52.png\n",
      "AtomsphericLightRGB [238. 142.  32.]\n",
      "***********************************************************\n",
      "parameterR 8.694288795100471\n",
      "********    file   ******** 102.png\n",
      "AtomsphericLightRGB [255. 157.  39.]\n",
      "***********************************************************\n",
      "parameterR 8.721260048759438\n",
      "********    file   ******** 358_img_.png\n",
      "AtomsphericLightRGB [157.91284   86.55963   28.073395]\n",
      "***********************************************************\n",
      "parameterR 3.514345870762977\n",
      "********    file   ******** 432.png\n",
      "AtomsphericLightRGB [255. 143.  28.]\n",
      "***********************************************************\n",
      "parameterR 13.407370968239519\n",
      "********    file   ******** 579.png\n",
      "AtomsphericLightRGB [252. 132.  40.]\n",
      "***********************************************************\n",
      "parameterR 14.716891671147472\n",
      "********    file   ******** 605.png\n",
      "AtomsphericLightRGB [254. 252.   0.]\n",
      "***********************************************************\n",
      "parameterR 10.77919983846897\n",
      "********    file   ******** 616.png\n",
      "AtomsphericLightRGB [167. 196.  41.]\n",
      "***********************************************************\n",
      "parameterR 17.812111664990987\n",
      "********    file   ******** 627.png\n",
      "AtomsphericLightRGB [214. 211.  32.]\n",
      "***********************************************************\n",
      "parameterR 8.280030341709487\n",
      "********    file   ******** 643_img_.png\n",
      "AtomsphericLightRGB [109.  62.   6.]\n",
      "***********************************************************\n",
      "parameterR 2.523564037282577\n",
      "********    file   ******** 770.png\n",
      "AtomsphericLightRGB [215.66489  179.04256  111.223404]\n",
      "***********************************************************\n",
      "parameterR 5.170090525379212\n",
      "********    file   ******** 866.png\n",
      "AtomsphericLightRGB [161.70732 189.07317  73.39024]\n",
      "***********************************************************\n",
      "parameterR 4.572016896139636\n",
      "********    file   ******** 880.png\n",
      "AtomsphericLightRGB [141.54185  157.26872   66.277534]\n",
      "***********************************************************\n",
      "parameterR 2.53307490410137\n",
      "********    file   ******** 2575.png\n",
      "AtomsphericLightRGB [188.6157  248.67769  91.67355]\n",
      "***********************************************************\n",
      "parameterR 8.959974520293132\n",
      "********    file   ******** 2583.png\n",
      "AtomsphericLightRGB [197.04546 249.20454  89.25   ]\n",
      "***********************************************************\n",
      "parameterR 12.47146874296652\n",
      "********    file   ******** 2856.png\n",
      "AtomsphericLightRGB [227. 255.  45.]\n",
      "***********************************************************\n",
      "parameterR 7.469158065578899\n",
      "********    file   ******** 3027.png\n",
      "AtomsphericLightRGB [233. 245.  53.]\n",
      "***********************************************************\n",
      "parameterR 3.294377285014764\n",
      "********    file   ******** 3051.png\n",
      "AtomsphericLightRGB [189. 241.  22.]\n",
      "***********************************************************\n",
      "parameterR 10.382787330628851\n",
      "********    file   ******** 3087.png\n",
      "AtomsphericLightRGB [229. 247.  77.]\n",
      "***********************************************************\n",
      "parameterR 2.7707100134809934\n",
      "********    file   ******** 3175.png\n",
      "AtomsphericLightRGB [241.36363   96.818184   8.181818]\n",
      "***********************************************************\n",
      "parameterR 41.534325782570214\n",
      "********    file   ******** 3201.png\n",
      "AtomsphericLightRGB [206.55 249.9   45.9 ]\n",
      "***********************************************************\n",
      "parameterR 3.571484241533831\n",
      "********    file   ******** 3279.png\n",
      "AtomsphericLightRGB [142.54659 131.45963  39.59627]\n",
      "***********************************************************\n",
      "parameterR 4.483827393775177\n",
      "********    file   ******** 3494.png\n",
      "AtomsphericLightRGB [249. 253.  26.]\n",
      "***********************************************************\n",
      "parameterR 9.972666321798666\n",
      "********    file   ******** 3519.png\n",
      "AtomsphericLightRGB [210. 156.  43.]\n",
      "***********************************************************\n",
      "parameterR 11.816370934102165\n",
      "********    file   ******** 6333.png\n",
      "AtomsphericLightRGB [164.8035  213.79913  61.24454]\n",
      "***********************************************************\n",
      "parameterR 8.41637574698384\n",
      "********    file   ******** 6340.png\n",
      "AtomsphericLightRGB [180.70866 226.88977  75.29527]\n",
      "***********************************************************\n",
      "parameterR 6.6503302203291454\n",
      "********    file   ******** 6527.png\n",
      "AtomsphericLightRGB [223.77551 244.59184  77.02041]\n",
      "***********************************************************\n",
      "parameterR 6.93839297332518\n",
      "********    file   ******** 7277.png\n",
      "AtomsphericLightRGB [242.56097 222.65854   0.     ]\n",
      "***********************************************************\n",
      "parameterR 145.15182919205526\n",
      "********    file   ******** 7291.png\n",
      "AtomsphericLightRGB [155. 102.   0.]\n",
      "***********************************************************\n",
      "parameterR 213.67214288049493\n",
      "********    file   ******** 9553.png\n",
      "AtomsphericLightRGB [147.78409   86.931816  46.363636]\n",
      "***********************************************************\n",
      "parameterR 2.056188169256837\n",
      "********    file   ******** 9602.png\n",
      "AtomsphericLightRGB [219.03847 183.07692  91.53846]\n",
      "***********************************************************\n",
      "parameterR 5.44472200058736\n",
      "********    file   ******** 9607.png\n",
      "AtomsphericLightRGB [187.47035 155.21739  95.75099]\n",
      "***********************************************************\n",
      "parameterR 4.941951933954831\n",
      "********    file   ******** 9618.png\n",
      "AtomsphericLightRGB [218. 191.  50.]\n",
      "***********************************************************\n",
      "parameterR 3.62220948311403\n",
      "********    file   ******** 10091.png\n",
      "AtomsphericLightRGB [116. 135.  42.]\n",
      "***********************************************************\n",
      "parameterR 7.520187550598756\n",
      "********    file   ******** 10103.png\n",
      "AtomsphericLightRGB [176.28261 206.21739 107.54348]\n",
      "***********************************************************\n",
      "parameterR 4.678691764344816\n",
      "********    file   ******** 10167.png\n",
      "AtomsphericLightRGB [255. 189.  20.]\n",
      "***********************************************************\n",
      "parameterR 8.87266668535553\n",
      "********    file   ******** 10226.png\n",
      "AtomsphericLightRGB [146.31148 199.61066 112.86885]\n",
      "***********************************************************\n",
      "parameterR 3.7722648751909107\n",
      "********    file   ******** 10475.png\n",
      "AtomsphericLightRGB [131.82204  101.567795  62.66949 ]\n",
      "***********************************************************\n",
      "parameterR 6.081872706877321\n",
      "********    file   ******** 10488.png\n",
      "AtomsphericLightRGB [50.04673  64.345795 25.023365]\n",
      "***********************************************************\n",
      "parameterR 10.954334961086396\n",
      "********    file   ******** 12191.png\n",
      "AtomsphericLightRGB [110.  74.  20.]\n",
      "***********************************************************\n",
      "parameterR 11.329600705489707\n",
      "********    file   ******** 12203.png\n",
      "AtomsphericLightRGB [150.  77.  58.]\n",
      "***********************************************************\n",
      "parameterR 8.61535012518445\n",
      "********    file   ******** 12228.png\n",
      "AtomsphericLightRGB [111.87747  97.7668   39.3083 ]\n",
      "***********************************************************\n",
      "parameterR 18.239021183910065\n",
      "********    file   ******** 12565.png\n",
      "AtomsphericLightRGB [168. 141.  39.]\n",
      "***********************************************************\n",
      "parameterR 13.587339044172403\n",
      "********    file   ******** 12577.png\n",
      "AtomsphericLightRGB [145.  87.  53.]\n",
      "***********************************************************\n",
      "parameterR 9.145870901372167\n",
      "********    file   ******** 12625.png\n",
      "AtomsphericLightRGB [191.25     142.13115   56.434425]\n",
      "***********************************************************\n",
      "parameterR 17.807738685754185\n",
      "********    file   ******** 12709.png\n",
      "AtomsphericLightRGB [160.93333 170.      106.53333]\n",
      "***********************************************************\n",
      "parameterR 13.913449851018173\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "********    file   ******** 12753.png\n",
      "AtomsphericLightRGB [244. 175.   6.]\n",
      "***********************************************************\n",
      "parameterR 22.219149427635806\n",
      "********    file   ******** 12960.png\n",
      "AtomsphericLightRGB [198.73239  155.6338    44.295776]\n",
      "***********************************************************\n",
      "parameterR 5.707145057909679\n",
      "********    file   ******** 12972.png\n",
      "AtomsphericLightRGB [144. 113.  20.]\n",
      "***********************************************************\n",
      "parameterR 5.352839120602233\n",
      "********    file   ******** 13252.png\n",
      "AtomsphericLightRGB [255.        227.3494      1.0240964]\n",
      "***********************************************************\n",
      "parameterR 19.25450099777634\n",
      "********    file   ******** 13259.png\n",
      "AtomsphericLightRGB [173. 141.  90.]\n",
      "***********************************************************\n",
      "parameterR 7.257326777041773\n",
      "********    file   ******** 15735.png\n",
      "AtomsphericLightRGB [ 52. 208. 203.]\n",
      "***********************************************************\n",
      "parameterR 1.745812487843922\n",
      "********    file   ******** 15738.png\n",
      "AtomsphericLightRGB [ 56. 175. 164.]\n",
      "***********************************************************\n",
      "parameterR 1.731321894808616\n",
      "********    file   ******** 15740.png\n",
      "AtomsphericLightRGB [178.07263 172.3743   95.44693]\n",
      "***********************************************************\n",
      "parameterR 4.632090854278731\n",
      "********    file   ******** 15774.png\n",
      "AtomsphericLightRGB [111.048386  67.17742    0.      ]\n",
      "***********************************************************\n",
      "parameterR 2.7560256248805013\n",
      "********    file   ******** 15775.png\n",
      "AtomsphericLightRGB [149.67392  145.51631   54.048912]\n",
      "***********************************************************\n",
      "parameterR 11.44012950512201\n",
      "********    file   ******** 100001.png\n",
      "AtomsphericLightRGB [ 62.975708 251.90283  189.95952 ]\n",
      "***********************************************************\n",
      "parameterR 1.4653063536906004\n",
      "********    file   ******** new1_1.png\n",
      "AtomsphericLightRGB [95.347824 82.04348  80.934784]\n",
      "***********************************************************\n",
      "parameterR 2.648514354810815\n",
      "********    file   ******** new1_2.png\n",
      "AtomsphericLightRGB [88.00885 75.59734 71.08407]\n",
      "***********************************************************\n",
      "parameterR 2.760056451674176\n",
      "********    file   ******** new1_3.png\n",
      "AtomsphericLightRGB [77.9476  71.26637 61.24454]\n",
      "***********************************************************\n",
      "parameterR 2.548020031360125\n",
      "********    file   ******** new1_4.png\n",
      "AtomsphericLightRGB [84.63362  75.840515 69.24569 ]\n",
      "***********************************************************\n",
      "parameterR 2.6295884066781983\n",
      "********    file   ******** new1_5.png\n",
      "AtomsphericLightRGB [80.174675 70.15284  70.15284 ]\n",
      "***********************************************************\n",
      "parameterR 2.668665285790547\n",
      "********    file   ******** new1_8.png\n",
      "AtomsphericLightRGB [78.95397 56.54812 53.34728]\n",
      "***********************************************************\n",
      "parameterR 2.628416347104291\n",
      "********    file   ******** new1_10.png\n",
      "AtomsphericLightRGB [94.95816  76.82008  52.280334]\n",
      "***********************************************************\n",
      "parameterR 3.647086704138474\n",
      "********    file   ******** new1_11.png\n",
      "AtomsphericLightRGB [ 95.48458 113.45815  90.99119]\n",
      "***********************************************************\n",
      "parameterR 2.8107694103711345\n",
      "********    file   ******** new1_18.png\n",
      "AtomsphericLightRGB [82.76316 95.06579 79.4079 ]\n",
      "***********************************************************\n",
      "parameterR 2.719071581906325\n",
      "********    file   ******** new1_19.png\n",
      "AtomsphericLightRGB [108.632286 133.78923  117.780266]\n",
      "***********************************************************\n",
      "parameterR 2.9426589634448326\n",
      "Time 0:29:00.179430\n"
     ]
    }
   ],
   "source": [
    "# Main\n",
    "\n",
    "np.seterr(over='ignore')\n",
    "if __name__ == '__main__':\n",
    "    pass\n",
    "\n",
    "starttime = datetime.datetime.now()\n",
    "\n",
    "# folder = \"C:/Users/Administrator/Desktop/UnderwaterImageEnhancement/Physical/GBdehazingRCorrection\"\n",
    "folder = r\"C:\\Users\\Saptarshi\\Project\\Restore\"\n",
    "path = folder + \"/InputImages\"\n",
    "files = os.listdir(path)\n",
    "files =  natsort.natsorted(files)\n",
    "\n",
    "for i in range(len(files)):\n",
    "    file = files[i]\n",
    "    filepath = path + \"/\" + file\n",
    "    prefix = file.split('.')[0]\n",
    "    if os.path.isfile(filepath):\n",
    "        print('********    file   ********',file)\n",
    "        img = cv2.imread(folder +'/InputImages/' + file)\n",
    "        img = (img - img.min()) / (img.max() - img.min()) * 255\n",
    "        blockSize = 9\n",
    "        largestDiff = determineDepth(img, blockSize)\n",
    "        AtomsphericLight, AtomsphericLightGB, AtomsphericLightRGB = getAtomsphericLight(largestDiff, img)\n",
    "        print('AtomsphericLightRGB',AtomsphericLightRGB)\n",
    "        \n",
    "        # transmission = getTransmission(img, AtomsphericLightRGB, blockSize=blockSize)\n",
    "        transmission = getTransmission(img, AtomsphericLightRGB, blockSize)\n",
    "        # print('transmission.shape',transmission.shape)\n",
    "        # TransmissionComposition(folder, transmission, number, param='coarse')\n",
    "        transmission = refinedtransmission(transmission, img)\n",
    "\n",
    "        cv2.imwrite('OutputImages/' + prefix + '_GBDehazedRcoorectionUDCP_TM.jpg', np.uint8(transmission[:, :, 0] * 255))\n",
    "\n",
    "\n",
    "        # TransmissionComposition(folder, transmission, number, param='refined_15_175_175')\n",
    "        sceneRadiance_GB = sceneRadianceGB(img, transmission, AtomsphericLightRGB)\n",
    "\n",
    "        # cv2.imwrite('OutputImages/' + prefix + 'GBDehazed.jpg', sceneRadiance_GB)\n",
    "\n",
    "\n",
    "        # # print('sceneRadiance_GB',sceneRadiance_GB)\n",
    "        sceneRadiance = sceneradiance(img, sceneRadiance_GB)\n",
    "        # sceneRadiance= sceneRadiance_GB\n",
    "        # cv2.imwrite('OutputImages/'+ prefix + 'GBDehazedRcoorectionUDCP.jpg', sceneRadiance)\n",
    "        # # print('np.min(sceneRadiance)',np.min(sceneRadiance))\n",
    "        # # print('sceneRadiance',sceneRadiance)\n",
    "        \n",
    "        S_x = AdaptiveExposureMap(img, sceneRadiance, Lambda=0.3, blockSize=blockSize)\n",
    "        # print('S_x',S_x)\n",
    "        sceneRadiance = AdaptiveSceneRadiance(sceneRadiance, S_x)\n",
    "        \n",
    "        # print('sceneRadiance',sceneRadiance)\n",
    "        cv2.imwrite('OutputImages/' + prefix + 'GBDehazedRcoorectionUDCPAdaptiveMap.jpg', sceneRadiance)\n",
    "\n",
    "\n",
    "Endtime = datetime.datetime.now()\n",
    "Time = Endtime - starttime\n",
    "print('Time', Time)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ae95fbc",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
